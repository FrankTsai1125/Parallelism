================================================================================
Bitcoin Miner ä¼˜åŒ–æŠ¥å‘Š - æ–¹æ¡ˆ A+B å®æ–½è®¡åˆ’
================================================================================
å­¦å·ï¼šp13922006
ç›®æ ‡ï¼šå°† case01 æ€§èƒ½ä» 4.20s ä¼˜åŒ–åˆ° 2.0-2.5s

================================================================================
ä¸€ã€æ·±åº¦åˆ†ææ€»ç»“ï¼ˆ10 åˆ†é’Ÿæ€è€ƒåï¼‰
================================================================================

### å½“å‰æ€§èƒ½ç“¶é¢ˆ

ç»è¿‡è¯¦ç»†çš„ nsys profiling å’Œå¤šæ¬¡å®éªŒï¼Œç¡®è®¤äº†ä»¥ä¸‹äº‹å®ï¼š

1. **GPU Kernel æœ¬èº«å·²ç»å¾ˆå¿«** (10.3 ms/kernel)
   - 512 blocks Ã— 256 threads é…ç½®æ¥è¿‘æœ€ä¼˜
   - 16M chunk_size åœ¨ launch overhead å’Œ overlap ä¹‹é—´è¾¾åˆ°å¹³è¡¡

2. **çœŸæ­£çš„ç“¶é¢ˆæ˜¯æ¶æ„æ€§çš„** (ä¸æ˜¯å‚æ•°æ€§çš„)
   - å½“å‰æ¶æ„æ˜¯"ååº”å¼"ï¼šWait â†’ Check â†’ Launch
   - æ¯ä¸ª stream åŒæ—¶åªæœ‰ 1 ä¸ª kernel è¿è¡Œ
   - Overlap æ•ˆç‡åªæœ‰ 6.1%ï¼Œè¿™æ˜¯å½“å‰æ¶æ„çš„æé™

3. **å®éªŒè¯æ˜çš„äº‹å®**
   - å‡å°‘ blocks_per_grid åˆ° 256ï¼šå• kernel æ…¢ 19%ï¼Œæ€»æ—¶é—´æ›´æ…¢
   - å¢åŠ  chunk_size åˆ° 64Mï¼šlaunch å‡å°‘ 75%ï¼Œä½† overlap ä¸‹é™ 4.6%ï¼Œæ€»æ—¶é—´ä¸å˜
   - è°ƒæ•´ usleepã€æ¶ˆé™¤é‡å¤ queryï¼šCPU æ•ˆç‡æå‡ï¼Œä½†å¢™ä¸Šæ—¶é—´æ”¹å–„å¾®å°

### è¦è¾¾åˆ° 3.0-3.5s éœ€è¦ä»€ä¹ˆï¼Ÿ

**æ•°å­¦åˆ†æï¼š**
- å½“å‰ GPU æ€»æ—¶é—´ï¼š4,485 ms
- å½“å‰å¢™ä¸Šæ—¶é—´ï¼š4,210 ms
- é€šè¿‡å¹¶è¡ŒèŠ‚çœï¼š275 ms (6.1%)
- è¦è¾¾åˆ° 3,500 msï¼šéœ€è¦èŠ‚çœ 985 ms
- **éœ€è¦ 3.6Ã— çš„å¹¶è¡Œæå‡ï¼**

**ç»“è®ºï¼š** å¿…é¡»è¿›è¡Œæ¶æ„çº§åˆ«çš„æ”¹å˜

================================================================================
äºŒã€æ–¹æ¡ˆ A+B æ€»ä½“ç­–ç•¥
================================================================================

### æ–¹æ¡ˆ Aï¼šPrefetch Pipelineï¼ˆOverlap ä¼˜åŒ–ï¼‰
**æ ¸å¿ƒæ€æƒ³ï¼š** "æ»‘åŠ¨çª—å£"prefetchï¼Œè€Œä¸æ˜¯ç®€å•çš„é¢„å…ˆ launch æ‰€æœ‰

**æ¶æ„æ”¹å˜ï¼š**
```
å½“å‰ï¼ˆååº”å¼ï¼‰ï¼š
Stream 0: [K0] wait â†’ [K1] wait â†’ [K2] wait...
                â†‘ ä¸²è¡Œç­‰å¾…

ä¼˜åŒ–åï¼ˆä¸»åŠ¨å¼ï¼‰ï¼š
Stream 0: [K0 running] [K1 queued] [K2 queued] [K3 queued]
          â†‘ åŒæ—¶æœ‰å¤šä¸ª kernels åœ¨ CUDA queue ä¸­
```

**å…³é”®ç‰¹æ€§ï¼š**
1. ä¿æŒ 2-8 ä¸ª kernels åœ¨æ¯ä¸ª stream çš„ queue ä¸­
2. åŠ¨æ€è°ƒæ•´ prefetch çª—å£å¤§å°
3. ä¿ç•™ early exit èƒ½åŠ›ï¼ˆé€šè¿‡ d_found è®© queued kernels å¿«é€Ÿé€€å‡ºï¼‰
4. æµªè´¹è®¡ç®— < 5%

**é¢„æœŸæ•ˆæœï¼š**
- Overlap æ•ˆç‡ï¼š6% â†’ 50-60%
- èŠ‚çœæ—¶é—´ï¼š~1,400 ms

---

### æ–¹æ¡ˆ Bï¼šSHA-256 Kernel ä¼˜åŒ–ï¼ˆThroughput ä¼˜åŒ–ï¼‰
**æ ¸å¿ƒæ€æƒ³ï¼š** ç®—æ³•çº§ä¼˜åŒ–ï¼Œé¿å…æ±‡ç¼–çº§è°ƒä¼˜çš„é«˜é£é™©

**ä¼˜åŒ–ç‚¹ï¼š**
1. **å‡å°‘ shared memory åŠ è½½å»¶è¿Ÿ**
   - è®©æ›´å¤š threads å‚ä¸åŠ è½½
   - å‡å°‘ bank conflicts

2. **ä½¿ç”¨ç¡¬ä»¶åŠ é€ŸæŒ‡ä»¤**
   - `__byte_perm` æ›¿ä»£æ‰‹åŠ¨ä½æ“ä½œ
   - å­—èŠ‚åºè½¬æ¢åŠ é€Ÿ

3. **å‡å°‘ register ä½¿ç”¨**
   - å¤ç”¨ chunk1 æ•°ç»„å­˜å‚¨ intermediate
   - ä» 56 registers â†’ 24 registers
   - æå‡ occupancy

4. **ä¼˜åŒ– early exit æ£€æŸ¥**
   - åŠ¨æ€è°ƒæ•´æ£€æŸ¥é¢‘ç‡
   - å‡å°‘ atomic read æ¬¡æ•°

**é¢„æœŸæ•ˆæœï¼š**
- Kernel åŠ é€Ÿï¼š10-15%
- GPU æ€»æ—¶é—´ï¼š4,485 ms â†’ 3,800-4,000 ms
- èŠ‚çœæ—¶é—´ï¼š~485-685 ms

---

### A+B ååŒæ•ˆåº”
- æ›´å¿«çš„ kernel (B) è®© prefetch (A) æ›´æœ‰æ•ˆ
- æ›´å¥½çš„ overlap (A) è®© kernel ä¼˜åŒ– (B) çš„æ”¶ç›Šæ›´æ˜æ˜¾
- **æ€»é¢„æœŸï¼šèŠ‚çœ 2,300 msï¼Œæœ€ç»ˆ 1,900-2,200 ms** âœ“âœ“âœ“

================================================================================
ä¸‰ã€è¯¦ç»†å®æ–½æ­¥éª¤
================================================================================

## é˜¶æ®µ 1ï¼šæ–¹æ¡ˆ B - Kernel ä¼˜åŒ–ï¼ˆå…ˆåšï¼Œé£é™©ä½ï¼‰

### B.1 ä¼˜åŒ– shared memory åŠ è½½
**ä½ç½®ï¼š** mine_kernel_global, ç¬¬ 476-486 è¡Œ

**ä¿®æ”¹å‰ï¼š**
```cuda
if (threadIdx.x < 8) {
    s_midstate[threadIdx.x] = midstate[threadIdx.x];
}
if (threadIdx.x < 16) {
    s_chunk1_base[threadIdx.x] = chunk1_base[threadIdx.x];
}
__syncthreads();
```

**ä¿®æ”¹åï¼š**
```cuda
// è®©å‰ 8 ä¸ª threads åŒæ—¶åŠ è½½ midstate å’Œ chunk1_base
if (threadIdx.x < 8) {
    s_midstate[threadIdx.x] = midstate[threadIdx.x];
    s_chunk1_base[threadIdx.x] = chunk1_base[threadIdx.x];
    s_chunk1_base[threadIdx.x + 8] = chunk1_base[threadIdx.x + 8];
}
__syncthreads();
```

**åŸç†ï¼š** å‡å°‘åŠ è½½è½®æ¬¡ï¼Œæå‡ memory bandwidth åˆ©ç”¨ç‡
**é¢„æœŸï¼š** 1-2% kernel åŠ é€Ÿ

---

### B.2 ä½¿ç”¨ç¡¬ä»¶å­—èŠ‚åºè½¬æ¢
**ä½ç½®ï¼š** mine_kernel_global, ç¬¬ 512-515 è¡Œ

**ä¿®æ”¹å‰ï¼š**
```cuda
chunk1[3] = ((nonce & 0x000000FFu) << 24) |
            ((nonce & 0x0000FF00u) << 8)  |
            ((nonce & 0x00FF0000u) >> 8)  |
            ((nonce & 0xFF000000u) >> 24);
```

**ä¿®æ”¹åï¼š**
```cuda
chunk1[3] = __byte_perm(nonce, 0, 0x0123);
```

**åŸç†ï¼š** ä½¿ç”¨ GPU ç¡¬ä»¶çš„å­—èŠ‚é‡æ’æŒ‡ä»¤ï¼Œ1 æ¡æŒ‡ä»¤å®Œæˆ
**é¢„æœŸï¼š** 0.5-1% kernel åŠ é€Ÿ

---

### B.3 å‡å°‘ register ä½¿ç”¨ï¼ˆæœ€é‡è¦çš„ä¼˜åŒ–ï¼‰
**ä½ç½®ï¼š** mine_kernel_global, ç¬¬ 500-530 è¡Œ

**ä¿®æ”¹å‰ï¼š**
```cuda
WORD state[8];           // 8 registers
WORD chunk1[16];         // 16 registers
unsigned char intermediate[32];  // 32 registers
// æ€»è®¡ï¼š56 registers

// ç¬¬ä¸€æ¬¡ hash
device_sha256_transform_words(state, chunk1);

// è½¬æ¢ä¸º bytes
for (int j = 0; j < 8; ++j) {
    WORD val = state[j];
    intermediate[4*j + 0] = (val >> 24) & 0xff;
    intermediate[4*j + 1] = (val >> 16) & 0xff;
    intermediate[4*j + 2] = (val >> 8) & 0xff;
    intermediate[4*j + 3] = val & 0xff;
}

// ç¬¬äºŒæ¬¡ hash
SHA256 hash;
device_sha256(&hash, intermediate, 32);
```

**ä¿®æ”¹åï¼š**
```cuda
WORD state[8];    // 8 registers
WORD chunk1[16];  // 16 registers
// æ€»è®¡ï¼š24 registers (-32 registers!)

// ç¬¬ä¸€æ¬¡ hash
device_sha256_transform_words(state, chunk1);

// å¤ç”¨ chunk1[0-7] å­˜å‚¨ intermediate (ä»¥ big-endian æ ¼å¼)
#pragma unroll
for (int j = 0; j < 8; ++j) {
    chunk1[j] = state[j];  // ä¿æŒå¤§ç«¯åº
}

// ç¬¬äºŒæ¬¡ hash (ç›´æ¥ä» chunk1 è¯»å–ï¼Œä½œä¸º unsigned char*)
SHA256 hash;
device_sha256(&hash, (unsigned char*)chunk1, 32);
```

**åŸç†ï¼š**
- å‡å°‘ 32 ä¸ª register ä½¿ç”¨
- Occupancy æå‡ï¼šå¯èƒ½ä» 50% â†’ 75%
- æ›´å¤š warps å¯ä»¥åŒæ—¶è¿è¡Œ

**é¢„æœŸï¼š** 5-8% kernel åŠ é€Ÿ â­â­â­

---

### B.4 ä¼˜åŒ– early exit æ£€æŸ¥é¢‘ç‡
**ä½ç½®ï¼š** mine_kernel_global, ç¬¬ 492-495 è¡Œ

**ä¿®æ”¹å‰ï¼š**
```cuda
if ((i & 0x1F) == 0 && *found) {
    return;
}
```

**ä¿®æ”¹åï¼š**
```cuda
// å‰æœŸå°‘æ£€æŸ¥ï¼ˆå‡å°‘ atomic readï¼‰ï¼ŒåæœŸå¤šæ£€æŸ¥ï¼ˆå¿«é€Ÿé€€å‡ºï¼‰
unsigned int check_mask = (i < nonce_count/2) ? 0x7F : 0x1F;
if ((i & check_mask) == 0 && *found) {
    return;
}
```

**åŸç†ï¼š** åŠ¨æ€å¹³è¡¡æ£€æŸ¥å¼€é”€å’Œé€€å‡ºé€Ÿåº¦
**é¢„æœŸï¼š** 1-2% kernel åŠ é€Ÿ

---

### B.5 æµ‹è¯•æ–¹æ¡ˆ B

**æµ‹è¯•æ­¥éª¤ï¼š**
1. å®æ–½ B.1-B.4 æ‰€æœ‰ä¼˜åŒ–
2. ç¼–è¯‘ï¼š`make`
3. æ­£ç¡®æ€§æµ‹è¯•ï¼š`./hw4 testcases/case01.in outputs/case01_b.out`
4. æ€§èƒ½æµ‹è¯•ï¼š`/usr/bin/time -v ./hw4 testcases/case01.in outputs/case01_b.out`
5. Profileï¼š`nsys profile --stats=true ./hw4 testcases/case01.in outputs/case01_b.out`

**é¢„æœŸç»“æœï¼š**
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… case01: 4.20s â†’ 3.6-3.8s
- âœ… Kernel æ—¶é—´ï¼š10.3ms â†’ 8.8-9.3ms

---

## é˜¶æ®µ 2ï¼šæ–¹æ¡ˆ A - Prefetch Pipelineï¼ˆéš¾åº¦é«˜ï¼Œæ½œåŠ›å¤§ï¼‰

### A.1 æ–°å¢æ•°æ®ç»“æ„
**ä½ç½®ï¼š** ç¬¬ 604 è¡Œåï¼ˆBlockTask ç»“æ„åï¼‰

**æ–°å¢ï¼š**
```cpp
// Prefetch context for sliding window pipeline
struct PrefetchContext {
    cudaStream_t stream;
    std::vector<cudaEvent_t> events;  // One event per chunk
    
    // Device memory (shared across chunks)
    unsigned char *d_target;
    WORD *d_midstate;
    WORD *d_chunk1_base;
    int *d_found;              // Shared found flag
    unsigned int *d_result;    // Shared result nonce
    
    // Host memory
    int h_found;
    unsigned int h_result_nonce;
    
    // State tracking
    int block_idx;             // Which block this stream is processing
    int chunks_launched;       // How many chunks have been launched
    int chunks_completed;      // How many chunks have completed
    int prefetch_window;       // Current prefetch window size (2-8)
    bool block_found;          // Whether this block found a nonce
    
    // Performance tracking
    float last_kernel_time;    // For dynamic window adjustment
};
```

---

### A.2 ä¿®æ”¹ mine_kernel_global æ·»åŠ å¿«é€Ÿé€€å‡º
**ä½ç½®ï¼š** ç¬¬ 466 è¡Œï¼Œmine_kernel_global å‡½æ•°å¼€å¤´

**ä¿®æ”¹ï¼š** åœ¨å‡½æ•°æœ€å¼€å§‹æ·»åŠ ï¼š
```cuda
__global__ void mine_kernel_global(
    unsigned char *target,
    WORD *midstate,
    WORD *chunk1_base,
    unsigned int start_nonce,
    unsigned int nonce_count,
    int *found,
    unsigned int *result_nonce
)
{
    // ã€æ–°å¢ã€‘First check: if already found, exit immediately
    if (*found) return;
    
    __shared__ WORD s_midstate[8];
    __shared__ WORD s_chunk1_base[16];
    
    // ... å…¶ä½™ä»£ç ä¸å˜ ...
}
```

**åŸç†ï¼š** è®© prefetch çš„ kernels èƒ½å¿«é€Ÿé€€å‡º

---

### A.3 é‡å†™ mine_blocks_pipelineï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰
**ä½ç½®ï¼š** ç¬¬ 625-787 è¡Œï¼Œå®Œå…¨é‡å†™

**æ–°æ¶æ„ï¼š**
```cpp
bool mine_blocks_pipeline(std::vector<BlockTask> &tasks)
{
    if (tasks.empty()) return true;
    
    const int max_streams = std::min(4, static_cast<int>(tasks.size()));
    const int threads_per_block = 256;
    const int blocks_per_grid = 512;
    const unsigned int chunk_size = 16777216;  // 16M
    const unsigned long long total_nonces = 0x100000000ULL;
    const int initial_prefetch_window = 4;     // åˆå§‹çª—å£å¤§å°
    
    // Initialize prefetch contexts
    std::vector<PrefetchContext> contexts(max_streams);
    
    for (int i = 0; i < max_streams; ++i) {
        PrefetchContext &ctx = contexts[i];
        
        // Create stream
        cudaStreamCreate(&ctx.stream);
        
        // Allocate device memory
        cudaMalloc(&ctx.d_target, 32);
        cudaMalloc(&ctx.d_midstate, 8 * sizeof(WORD));
        cudaMalloc(&ctx.d_chunk1_base, 16 * sizeof(WORD));
        cudaMalloc(&ctx.d_found, sizeof(int));
        cudaMalloc(&ctx.d_result, sizeof(unsigned int));
        
        // Copy initial data
        BlockTask &task = tasks[i];
        cudaMemcpyAsync(ctx.d_target, task.target, 32, 
                        cudaMemcpyHostToDevice, ctx.stream);
        cudaMemcpyAsync(ctx.d_midstate, task.midstate, 8 * sizeof(WORD),
                        cudaMemcpyHostToDevice, ctx.stream);
        cudaMemcpyAsync(ctx.d_chunk1_base, task.chunk1_base, 16 * sizeof(WORD),
                        cudaMemcpyHostToDevice, ctx.stream);
        
        // Initialize found flag
        cudaMemsetAsync(ctx.d_found, 0, sizeof(int), ctx.stream);
        
        // Initialize state
        ctx.block_idx = i;
        ctx.chunks_launched = 0;
        ctx.chunks_completed = 0;
        ctx.prefetch_window = initial_prefetch_window;
        ctx.block_found = false;
        ctx.h_found = 0;
        ctx.last_kernel_time = 10.0f;
    }
    
    // Prefetch initial window of kernels for each stream
    for (int i = 0; i < max_streams; ++i) {
        PrefetchContext &ctx = contexts[i];
        
        for (int w = 0; w < ctx.prefetch_window; ++w) {
            unsigned int start_nonce = w * chunk_size;
            if (start_nonce >= total_nonces) break;
            
            // Create event for this chunk
            cudaEvent_t event;
            cudaEventCreate(&event);
            ctx.events.push_back(event);
            
            // Launch kernel
            mine_kernel_global<<<blocks_per_grid, threads_per_block, 0, ctx.stream>>>(
                ctx.d_target,
                ctx.d_midstate,
                ctx.d_chunk1_base,
                start_nonce,
                chunk_size,
                ctx.d_found,
                ctx.d_result
            );
            
            // Record event
            cudaEventRecord(event, ctx.stream);
            ctx.chunks_launched++;
        }
    }
    
    // Main loop: check completion and launch new chunks
    int completed_blocks = 0;
    
    while (completed_blocks < max_streams) {
        // Phase 1: Check for completed chunks
        for (int i = 0; i < max_streams; ++i) {
            PrefetchContext &ctx = contexts[i];
            
            if (ctx.block_found) continue;  // Already found, skip
            
            // Check the oldest uncompleted chunk
            if (ctx.chunks_completed < ctx.events.size()) {
                cudaEvent_t event = ctx.events[ctx.chunks_completed];
                cudaError_t status = cudaEventQuery(event);
                
                if (status == cudaSuccess) {
                    // Chunk completed
                    ctx.chunks_completed++;
                    
                    // Check if found (async copy to avoid blocking)
                    cudaMemcpyAsync(&ctx.h_found, ctx.d_found, sizeof(int),
                                    cudaMemcpyDeviceToHost, ctx.stream);
                    cudaStreamSynchronize(ctx.stream);  // Wait for the flag
                    
                    if (ctx.h_found) {
                        // Found! Retrieve result
                        cudaMemcpyAsync(&ctx.h_result_nonce, ctx.d_result, 
                                        sizeof(unsigned int),
                                        cudaMemcpyDeviceToHost, ctx.stream);
                        cudaStreamSynchronize(ctx.stream);
                        
                        // Mark as found
                        ctx.block_found = true;
                        tasks[ctx.block_idx].block.nonce = ctx.h_result_nonce;
                        tasks[ctx.block_idx].completed = true;
                        completed_blocks++;
                        
                        // Stop prefetching for this stream
                        ctx.prefetch_window = 0;
                    }
                    else {
                        // Not found yet, check if exhausted
                        unsigned int next_start = ctx.chunks_launched * chunk_size;
                        if (next_start >= total_nonces) {
                            // Exhausted
                            ctx.block_found = true;
                            tasks[ctx.block_idx].block.nonce = 0;
                            tasks[ctx.block_idx].completed = true;
                            completed_blocks++;
                            ctx.prefetch_window = 0;
                        }
                    }
                }
            }
        }
        
        // Phase 2: Launch new chunks (maintain prefetch window)
        for (int i = 0; i < max_streams; ++i) {
            PrefetchContext &ctx = contexts[i];
            
            if (ctx.block_found) continue;
            
            // Maintain the prefetch window
            while (ctx.chunks_launched < ctx.chunks_completed + ctx.prefetch_window) {
                unsigned int start_nonce = ctx.chunks_launched * chunk_size;
                if (start_nonce >= total_nonces) break;
                
                // Create event
                cudaEvent_t event;
                cudaEventCreate(&event);
                ctx.events.push_back(event);
                
                // Launch kernel
                mine_kernel_global<<<blocks_per_grid, threads_per_block, 0, ctx.stream>>>(
                    ctx.d_target,
                    ctx.d_midstate,
                    ctx.d_chunk1_base,
                    start_nonce,
                    chunk_size,
                    ctx.d_found,
                    ctx.d_result
                );
                
                // Record event
                cudaEventRecord(event, ctx.stream);
                ctx.chunks_launched++;
            }
        }
        
        usleep(50);  // Reduce busy-polling
    }
    
    // Cleanup
    for (int i = 0; i < max_streams; ++i) {
        PrefetchContext &ctx = contexts[i];
        
        cudaStreamSynchronize(ctx.stream);
        
        for (auto event : ctx.events) {
            cudaEventDestroy(event);
        }
        
        cudaFree(ctx.d_target);
        cudaFree(ctx.d_midstate);
        cudaFree(ctx.d_chunk1_base);
        cudaFree(ctx.d_found);
        cudaFree(ctx.d_result);
        
        cudaStreamDestroy(ctx.stream);
    }
    
    return true;
}
```

**å…³é”®æ”¹å˜ï¼š**
1. é¢„å…ˆ launch 4 ä¸ª kernels åˆ°æ¯ä¸ª stream
2. å½“ä¸€ä¸ªå®Œæˆæ—¶ï¼Œç«‹å³ launch ä¸‹ä¸€ä¸ªï¼ˆæ»‘åŠ¨çª—å£ï¼‰
3. é€šè¿‡ d_found è®©åç»­ kernels å¿«é€Ÿé€€å‡º
4. ä¿æŒæ¯ä¸ª stream çš„ queue ä¸­å§‹ç»ˆæœ‰ 2-8 ä¸ª kernels

---

### A.4 ï¼ˆå¯é€‰ï¼‰åŠ¨æ€çª—å£è°ƒæ•´

åœ¨ Phase 1 æ£€æŸ¥å®Œæˆåæ·»åŠ ï¼š

```cpp
// Dynamic window adjustment (optional, for further optimization)
if (ctx.chunks_completed > 0 && ctx.chunks_completed < ctx.events.size()) {
    // Estimate kernel time from event timing
    cudaEvent_t prev_event = ctx.events[ctx.chunks_completed - 1];
    cudaEvent_t curr_event = ctx.events[ctx.chunks_completed];
    float elapsed_ms;
    cudaEventElapsedTime(&elapsed_ms, prev_event, curr_event);
    
    ctx.last_kernel_time = elapsed_ms;
    
    // Adjust window based on kernel time
    if (elapsed_ms < 9.0f) {
        // GPU has idle time, increase window
        ctx.prefetch_window = std::min(8, ctx.prefetch_window + 1);
    }
    else if (elapsed_ms > 12.0f) {
        // Too much contention, decrease window
        ctx.prefetch_window = std::max(2, ctx.prefetch_window - 1);
    }
}
```

---

### A.5 æµ‹è¯•æ–¹æ¡ˆ A

**æµ‹è¯•æ­¥éª¤ï¼š**
1. åœ¨æ–¹æ¡ˆ B çš„åŸºç¡€ä¸Šå®æ–½æ–¹æ¡ˆ A
2. ç¼–è¯‘ï¼š`make`
3. æ­£ç¡®æ€§æµ‹è¯•ï¼š`./hw4 testcases/case01.in outputs/case01_ab.out`
4. æ€§èƒ½æµ‹è¯•ï¼š`/usr/bin/time -v ./hw4 testcases/case01.in outputs/case01_ab.out`
5. Profileï¼š`nsys profile --stats=true ./hw4 testcases/case01.in outputs/case01_ab.out`

**é¢„æœŸç»“æœï¼š**
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… case01: 3.6-3.8s (after B) â†’ 2.0-2.5s
- âœ… Overlap æ•ˆç‡ï¼š6% â†’ 50-60%
- âœ… GPU ä¸ŠåŒæ—¶æœ‰ 8-16 ä¸ª kernels è¿è¡Œ

================================================================================
å››ã€é£é™©è¯„ä¼°ä¸å›æ»šæ–¹æ¡ˆ
================================================================================

### é£é™©ç­‰çº§
- **æ–¹æ¡ˆ B**: ğŸŸ¢ ä½é£é™©
  - å±€éƒ¨ä¼˜åŒ–ï¼Œä¸æ”¹å˜æ¶æ„
  - å¯ä»¥é€ä¸ªä¼˜åŒ–ç‚¹æµ‹è¯•
  - å®¹æ˜“å›æ»š

- **æ–¹æ¡ˆ A**: ğŸŸ¡ ä¸­ç­‰é£é™©
  - æ¶æ„æ”¹å˜è¾ƒå¤§
  - éœ€è¦ä»”ç»†ç®¡ç† events å’Œ streams
  - ä½†ä¿ç•™äº† early exitï¼Œæµªè´¹è®¡ç®— < 5%

### å›æ»šæ–¹æ¡ˆ
1. **ä¿å­˜å½“å‰ç‰ˆæœ¬**
   ```bash
   cp hw4.cu hw4_backup_4.20s.cu
   ```

2. **åˆ†é˜¶æ®µå®æ–½**
   - å…ˆå®Œæˆ Bï¼Œç¡®è®¤æ•ˆæœ
   - å¦‚æœ B å¤±è´¥ï¼Œå›æ»šåˆ° backup
   - å¦‚æœ B æˆåŠŸï¼Œå†å®æ–½ A

3. **æ¯ä¸ªé˜¶æ®µéƒ½æµ‹è¯•**
   - æ­£ç¡®æ€§æµ‹è¯•
   - æ€§èƒ½æµ‹è¯•
   - Profile åˆ†æ

================================================================================
äº”ã€é¢„æœŸæˆæœ
================================================================================

### æœ€ä¿å®ˆä¼°è®¡ (overlap 40%)
- æ–¹æ¡ˆ B: 4.20s â†’ 3.70s (-12%)
- æ–¹æ¡ˆ A: 3.70s â†’ 2.60s (-30%)
- **æ€»è®¡: 2.60s** âœ“

### é¢„æœŸä¼°è®¡ (overlap 50-60%)
- æ–¹æ¡ˆ B: 4.20s â†’ 3.65s (-13%)
- æ–¹æ¡ˆ A: 3.65s â†’ 2.20s (-40%)
- **æ€»è®¡: 2.20s** âœ“âœ“

### æœ€ç†æƒ³ä¼°è®¡ (overlap 70%)
- æ–¹æ¡ˆ B: 4.20s â†’ 3.60s (-14%)
- æ–¹æ¡ˆ A: 3.60s â†’ 1.85s (-49%)
- **æ€»è®¡: 1.85s** âœ“âœ“âœ“

### è¾¾æ ‡åˆ†æ
- ç›®æ ‡ï¼š3.0-3.5s
- é¢„æœŸï¼š2.0-2.5s
- **ç»“è®ºï¼šå¤§æ¦‚ç‡è¾¾æ ‡ï¼Œç”šè‡³è¶…è¶Šç›®æ ‡ï¼**

================================================================================
å…­ã€æ—¶é—´ä¼°è®¡
================================================================================

- æ–¹æ¡ˆ B å®æ–½ï¼š2-3 å°æ—¶
- æ–¹æ¡ˆ B æµ‹è¯•ï¼š30 åˆ†é’Ÿ
- æ–¹æ¡ˆ A å®æ–½ï¼š4-6 å°æ—¶
- æ–¹æ¡ˆ A æµ‹è¯•ï¼š1 å°æ—¶
- è°ƒä¼˜ä¸æ–‡æ¡£ï¼š2-3 å°æ—¶

**æ€»è®¡ï¼š10-14 å°æ—¶**

================================================================================
ä¸ƒã€æ€»ç»“
================================================================================

ç»è¿‡ 10 åˆ†é’Ÿæ·±åº¦æ€è€ƒï¼Œåˆ¶å®šäº†æ¸…æ™°çš„ A+B å®æ–½è·¯çº¿ï¼š

âœ… **æ–¹æ¡ˆå¯è¡Œæ€§é«˜**
- æ–¹æ¡ˆ B æ˜¯æˆç†Ÿçš„ç®—æ³•ä¼˜åŒ–æŠ€æœ¯
- æ–¹æ¡ˆ A æ˜¯åˆç†çš„æ¶æ„æ”¹è¿›ï¼ˆæ»‘åŠ¨çª—å£ prefetchï¼‰
- ä¿ç•™äº† early exit èƒ½åŠ›

âœ… **é£é™©å¯æ§**
- åˆ†é˜¶æ®µå®æ–½
- æ¯ä¸ªé˜¶æ®µç‹¬ç«‹æµ‹è¯•
- æœ‰æ˜ç¡®çš„å›æ»šæ–¹æ¡ˆ

âœ… **é¢„æœŸæ•ˆæœæ˜ç¡®**
- æ–¹æ¡ˆ B: 10-15% kernel åŠ é€Ÿ
- æ–¹æ¡ˆ A: overlap ä» 6% æå‡åˆ° 50-60%
- æ€»è®¡: 2.0-2.5sï¼Œè¿œè¶… 3.0-3.5s ç›®æ ‡

âœ… **å®æ–½æ­¥éª¤æ¸…æ™°**
- è¯¦ç»†çš„ä»£ç ä¿®æ”¹ä½ç½®
- æ¸…æ™°çš„æµ‹è¯•æµç¨‹
- æ˜ç¡®çš„æ€§èƒ½æŒ‡æ ‡

**ä¸‹ä¸€æ­¥ï¼šå¼€å§‹å®æ–½æ–¹æ¡ˆ Bï¼**
